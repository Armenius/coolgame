{"version":3,"sources":["../../../src/crypto/algorithms/megolm.js"],"names":["utils","require","olmlib","base","OutboundSessionInfo","sessionId","useCount","creationTime","Date","getTime","sharedWithDevices","prototype","needsRotation","rotationPeriodMsgs","rotationPeriodMs","sessionLifetime","console","log","sharedWithTooManyDevices","devicesInRoom","userId","hasOwnProperty","deviceId","MegolmEncryption","params","EncryptionAlgorithm","call","_setupPromise","resolve","_sessionRotationPeriodMsgs","_sessionRotationPeriodMs","config","rotation_period_ms","undefined","rotation_period_msgs","inherits","_ensureOutboundSession","oldSession","session","self","_roomId","_prepareNewSession","shareMap","userDevices","deviceInfo","key","getIdentityKey","_olmDevice","deviceCurve25519Key","push","_shareKeyWithDevices","prepareSession","returnSession","prom","then","createOutboundGroupSession","getOutboundGroupSessionKey","addInboundGroupSession","ed25519","deviceEd25519Key","devicesByUser","payload","type","content","algorithm","MEGOLM_ALGORITHM","room_id","session_id","session_key","chain_index","contentMap","ensureOlmSessionsForDevices","_baseApis","devicemap","promises","devicesToShareWith","sessionResults","i","length","sessionResult","encryptedContent","OLM_ALGORITHM","sender_key","ciphertext","encryptMessageForDevice","_userId","_deviceId","all","sendToDevice","encryptMessage","room","eventType","_getDevicesInRoom","_checkForUnknownDevices","payloadJson","encryptGroupMessage","device_id","unknownDevices","forEach","device","isUnverified","isKnown","UnknownDeviceError","roomMembers","map","getJoinedMembers","u","_crypto","downloadKeys","devices","isBlocked","getBlacklistUnverifiedDevices","getGlobalBlacklistUnverifiedDevices","MegolmDecryption","DecryptionAlgorithm","_pendingEvents","decryptEvent","event","getWireContent","DecryptionError","res","decryptGroupMessage","getRoomId","message","_addEventToPendingList","_requestKeysForEvent","toString","JSON","parse","result","clearEvent","senderCurve25519Key","senderKey","claimedEd25519Key","keysClaimed","forwardingCurve25519KeyChain","sender","getSender","wireContent","recipients","requestRoomKey","k","onRoomKeyEvent","getContent","getSenderKey","forwardingKeyChain","exportFormat","error","getType","forwarding_curve25519_key_chain","isArray","slice","ed25519Key","sender_claimed_ed25519_key","getKeysClaimed","cancelRoomKeyRequest","_retryDecryption","catch","e","hasKeysForKeyRequest","keyRequest","body","requestBody","hasInboundSessionKeys","shareKeysWithDevice","getStoredDevice","olmSessionResult","_buildKeyForwardingMessage","done","roomId","getInboundGroupSessionKey","importRoomKey","importInboundGroupSession","pending","attemptDecryption","registerAlgorithm"],"mappings":"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","file":"megolm.js","sourcesContent":["/*\nCopyright 2015, 2016 OpenMarket Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\"use strict\";\n\n/**\n * Defines m.olm encryption/decryption\n *\n * @module crypto/algorithms/megolm\n */\n\nimport Promise from 'bluebird';\n\nconst utils = require(\"../../utils\");\nconst olmlib = require(\"../olmlib\");\nconst base = require(\"./base\");\n\n/**\n * @private\n * @constructor\n *\n * @param {string} sessionId\n *\n * @property {string} sessionId\n * @property {Number} useCount     number of times this session has been used\n * @property {Number} creationTime when the session was created (ms since the epoch)\n *\n * @property {object} sharedWithDevices\n *    devices with which we have shared the session key\n *        userId -> {deviceId -> msgindex}\n */\nfunction OutboundSessionInfo(sessionId) {\n    this.sessionId = sessionId;\n    this.useCount = 0;\n    this.creationTime = new Date().getTime();\n    this.sharedWithDevices = {};\n}\n\n\n/**\n * Check if it's time to rotate the session\n *\n * @param {Number} rotationPeriodMsgs\n * @param {Number} rotationPeriodMs\n * @return {Boolean}\n */\nOutboundSessionInfo.prototype.needsRotation = function(\n    rotationPeriodMsgs, rotationPeriodMs,\n) {\n    const sessionLifetime = new Date().getTime() - this.creationTime;\n\n    if (this.useCount >= rotationPeriodMsgs ||\n        sessionLifetime >= rotationPeriodMs\n       ) {\n        console.log(\n            \"Rotating megolm session after \" + this.useCount +\n                \" messages, \" + sessionLifetime + \"ms\",\n        );\n        return true;\n    }\n\n    return false;\n};\n\n\n/**\n * Determine if this session has been shared with devices which it shouldn't\n * have been.\n *\n * @param {Object} devicesInRoom userId -> {deviceId -> object}\n *   devices we should shared the session with.\n *\n * @return {Boolean} true if we have shared the session with devices which aren't\n * in devicesInRoom.\n */\nOutboundSessionInfo.prototype.sharedWithTooManyDevices = function(\n    devicesInRoom,\n) {\n    for (const userId in this.sharedWithDevices) {\n        if (!this.sharedWithDevices.hasOwnProperty(userId)) {\n            continue;\n        }\n\n        if (!devicesInRoom.hasOwnProperty(userId)) {\n            console.log(\"Starting new session because we shared with \" + userId);\n            return true;\n        }\n\n        for (const deviceId in this.sharedWithDevices[userId]) {\n            if (!this.sharedWithDevices[userId].hasOwnProperty(deviceId)) {\n                continue;\n            }\n\n            if (!devicesInRoom[userId].hasOwnProperty(deviceId)) {\n                console.log(\n                    \"Starting new session because we shared with \" +\n                        userId + \":\" + deviceId,\n                );\n                return true;\n            }\n        }\n    }\n};\n\n\n/**\n * Megolm encryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/base.EncryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/base.EncryptionAlgorithm}\n */\nfunction MegolmEncryption(params) {\n    base.EncryptionAlgorithm.call(this, params);\n\n    // the most recent attempt to set up a session. This is used to serialise\n    // the session setups, so that we have a race-free view of which session we\n    // are using, and which devices we have shared the keys with. It resolves\n    // with an OutboundSessionInfo (or undefined, for the first message in the\n    // room).\n    this._setupPromise = Promise.resolve();\n\n    // default rotation periods\n    this._sessionRotationPeriodMsgs = 100;\n    this._sessionRotationPeriodMs = 7 * 24 * 3600 * 1000;\n\n    if (params.config.rotation_period_ms !== undefined) {\n        this._sessionRotationPeriodMs = params.config.rotation_period_ms;\n    }\n\n    if (params.config.rotation_period_msgs !== undefined) {\n        this._sessionRotationPeriodMsgs = params.config.rotation_period_msgs;\n    }\n}\nutils.inherits(MegolmEncryption, base.EncryptionAlgorithm);\n\n/**\n * @private\n *\n * @param {Object} devicesInRoom The devices in this room, indexed by user ID\n *\n * @return {module:client.Promise} Promise which resolves to the\n *    OutboundSessionInfo when setup is complete.\n */\nMegolmEncryption.prototype._ensureOutboundSession = function(devicesInRoom) {\n    const self = this;\n\n    let session;\n\n    // takes the previous OutboundSessionInfo, and considers whether to create\n    // a new one. Also shares the key with any (new) devices in the room.\n    // Updates `session` to hold the final OutboundSessionInfo.\n    //\n    // returns a promise which resolves once the keyshare is successful.\n    async function prepareSession(oldSession) {\n        session = oldSession;\n\n        // need to make a brand new session?\n        if (session && session.needsRotation(self._sessionRotationPeriodMsgs,\n                                             self._sessionRotationPeriodMs)\n           ) {\n            console.log(\"Starting new megolm session because we need to rotate.\");\n            session = null;\n        }\n\n        // determine if we have shared with anyone we shouldn't have\n        if (session && session.sharedWithTooManyDevices(devicesInRoom)) {\n            session = null;\n        }\n\n        if (!session) {\n            console.log(`Starting new megolm session for room ${self._roomId}`);\n            session = await self._prepareNewSession();\n        }\n\n        // now check if we need to share with any devices\n        const shareMap = {};\n\n        for (const userId in devicesInRoom) {\n            if (!devicesInRoom.hasOwnProperty(userId)) {\n                continue;\n            }\n\n            const userDevices = devicesInRoom[userId];\n\n            for (const deviceId in userDevices) {\n                if (!userDevices.hasOwnProperty(deviceId)) {\n                    continue;\n                }\n\n                const deviceInfo = userDevices[deviceId];\n\n                const key = deviceInfo.getIdentityKey();\n                if (key == self._olmDevice.deviceCurve25519Key) {\n                    // don't bother sending to ourself\n                    continue;\n                }\n\n                if (\n                    !session.sharedWithDevices[userId] ||\n                        session.sharedWithDevices[userId][deviceId] === undefined\n                ) {\n                    shareMap[userId] = shareMap[userId] || [];\n                    shareMap[userId].push(deviceInfo);\n                }\n            }\n        }\n\n        return self._shareKeyWithDevices(\n            session, shareMap,\n        );\n    }\n\n    // helper which returns the session prepared by prepareSession\n    function returnSession() {\n        return session;\n    }\n\n    // first wait for the previous share to complete\n    const prom = this._setupPromise.then(prepareSession);\n\n    // _setupPromise resolves to `session` whether or not the share succeeds\n    this._setupPromise = prom.then(returnSession, returnSession);\n\n    // but we return a promise which only resolves if the share was successful.\n    return prom.then(returnSession);\n};\n\n/**\n * @private\n *\n * @return {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n */\nMegolmEncryption.prototype._prepareNewSession = async function() {\n    const sessionId = this._olmDevice.createOutboundGroupSession();\n    const key = this._olmDevice.getOutboundGroupSessionKey(sessionId);\n\n    await this._olmDevice.addInboundGroupSession(\n        this._roomId, this._olmDevice.deviceCurve25519Key, [], sessionId,\n        key.key, {ed25519: this._olmDevice.deviceEd25519Key},\n    );\n\n    return new OutboundSessionInfo(sessionId);\n};\n\n/**\n * @private\n *\n * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n *\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n *    map from userid to list of devices\n *\n * @return {module:client.Promise} Promise which resolves once the key sharing\n *     message has been sent.\n */\nMegolmEncryption.prototype._shareKeyWithDevices = function(session, devicesByUser) {\n    const self = this;\n\n    const key = this._olmDevice.getOutboundGroupSessionKey(session.sessionId);\n    const payload = {\n        type: \"m.room_key\",\n        content: {\n            algorithm: olmlib.MEGOLM_ALGORITHM,\n            room_id: this._roomId,\n            session_id: session.sessionId,\n            session_key: key.key,\n            chain_index: key.chain_index,\n        },\n    };\n\n    const contentMap = {};\n\n    return olmlib.ensureOlmSessionsForDevices(\n        this._olmDevice, this._baseApis, devicesByUser,\n    ).then(function(devicemap) {\n        const promises = [];\n\n        for (const userId in devicesByUser) {\n            if (!devicesByUser.hasOwnProperty(userId)) {\n                continue;\n            }\n\n            const devicesToShareWith = devicesByUser[userId];\n            const sessionResults = devicemap[userId];\n\n            for (let i = 0; i < devicesToShareWith.length; i++) {\n                const deviceInfo = devicesToShareWith[i];\n                const deviceId = deviceInfo.deviceId;\n\n                const sessionResult = sessionResults[deviceId];\n                if (!sessionResult.sessionId) {\n                    // no session with this device, probably because there\n                    // were no one-time keys.\n                    //\n                    // we could send them a to_device message anyway, as a\n                    // signal that they have missed out on the key sharing\n                    // message because of the lack of keys, but there's not\n                    // much point in that really; it will mostly serve to clog\n                    // up to_device inboxes.\n                    //\n                    // ensureOlmSessionsForUsers has already done the logging,\n                    // so just skip it.\n                    continue;\n                }\n\n                console.log(\n                    \"sharing keys with device \" + userId + \":\" + deviceId,\n                );\n\n                const encryptedContent = {\n                    algorithm: olmlib.OLM_ALGORITHM,\n                    sender_key: self._olmDevice.deviceCurve25519Key,\n                    ciphertext: {},\n                };\n\n                if (!contentMap[userId]) {\n                    contentMap[userId] = {};\n                }\n\n                contentMap[userId][deviceId] = encryptedContent;\n\n                promises.push(\n                    olmlib.encryptMessageForDevice(\n                        encryptedContent.ciphertext,\n                        self._userId,\n                        self._deviceId,\n                        self._olmDevice,\n                        userId,\n                        deviceInfo,\n                        payload,\n                    ),\n                );\n            }\n        }\n\n        if (promises.length === 0) {\n            // no devices to send to\n            return Promise.resolve();\n        }\n\n        return Promise.all(promises).then(() => {\n            // TODO: retries\n            return self._baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n        });\n    }).then(function() {\n        console.log(`Completed megolm keyshare in ${self._roomId}`);\n\n        // Add the devices we have shared with to session.sharedWithDevices.\n        //\n        // we deliberately iterate over devicesByUser (ie, the devices we\n        // attempted to share with) rather than the contentMap (those we did\n        // share with), because we don't want to try to claim a one-time-key\n        // for dead devices on every message.\n        for (const userId in devicesByUser) {\n            if (!devicesByUser.hasOwnProperty(userId)) {\n                continue;\n            }\n            if (!session.sharedWithDevices[userId]) {\n                session.sharedWithDevices[userId] = {};\n            }\n            const devicesToShareWith = devicesByUser[userId];\n            for (let i = 0; i < devicesToShareWith.length; i++) {\n                const deviceInfo = devicesToShareWith[i];\n                session.sharedWithDevices[userId][deviceInfo.deviceId] =\n                    key.chain_index;\n            }\n        }\n    });\n};\n\n/**\n * @inheritdoc\n *\n * @param {module:models/room} room\n * @param {string} eventType\n * @param {object} content plaintext event content\n *\n * @return {module:client.Promise} Promise which resolves to the new event body\n */\nMegolmEncryption.prototype.encryptMessage = function(room, eventType, content) {\n    const self = this;\n    console.log(`Starting to encrypt event for ${this._roomId}`);\n\n    return this._getDevicesInRoom(room).then(function(devicesInRoom) {\n        // check if any of these devices are not yet known to the user.\n        // if so, warn the user so they can verify or ignore.\n        self._checkForUnknownDevices(devicesInRoom);\n\n        return self._ensureOutboundSession(devicesInRoom);\n    }).then(function(session) {\n        const payloadJson = {\n            room_id: self._roomId,\n            type: eventType,\n            content: content,\n        };\n\n        const ciphertext = self._olmDevice.encryptGroupMessage(\n            session.sessionId, JSON.stringify(payloadJson),\n        );\n\n        const encryptedContent = {\n            algorithm: olmlib.MEGOLM_ALGORITHM,\n            sender_key: self._olmDevice.deviceCurve25519Key,\n            ciphertext: ciphertext,\n            session_id: session.sessionId,\n             // Include our device ID so that recipients can send us a\n             // m.new_device message if they don't have our session key.\n            device_id: self._deviceId,\n        };\n\n        session.useCount++;\n        return encryptedContent;\n    });\n};\n\n/**\n * Checks the devices we're about to send to and see if any are entirely\n * unknown to the user.  If so, warn the user, and mark them as known to\n * give the user a chance to go verify them before re-sending this message.\n *\n * @param {Object} devicesInRoom userId -> {deviceId -> object}\n *   devices we should shared the session with.\n */\nMegolmEncryption.prototype._checkForUnknownDevices = function(devicesInRoom) {\n    const unknownDevices = {};\n\n    Object.keys(devicesInRoom).forEach((userId)=>{\n        Object.keys(devicesInRoom[userId]).forEach((deviceId)=>{\n            const device = devicesInRoom[userId][deviceId];\n            if (device.isUnverified() && !device.isKnown()) {\n                if (!unknownDevices[userId]) {\n                    unknownDevices[userId] = {};\n                }\n                unknownDevices[userId][deviceId] = device;\n            }\n        });\n    });\n\n    if (Object.keys(unknownDevices).length) {\n        // it'd be kind to pass unknownDevices up to the user in this error\n        throw new base.UnknownDeviceError(\n            \"This room contains unknown devices which have not been verified. \" +\n            \"We strongly recommend you verify them before continuing.\", unknownDevices);\n    }\n};\n\n/**\n * Get the list of unblocked devices for all users in the room\n *\n * @param {module:models/room} room\n *\n * @return {module:client.Promise} Promise which resolves to a map\n *     from userId to deviceId to deviceInfo\n */\nMegolmEncryption.prototype._getDevicesInRoom = function(room) {\n    // XXX what about rooms where invitees can see the content?\n    const roomMembers = utils.map(room.getJoinedMembers(), function(u) {\n        return u.userId;\n    });\n\n    // We are happy to use a cached version here: we assume that if we already\n    // have a list of the user's devices, then we already share an e2e room\n    // with them, which means that they will have announced any new devices via\n    // an m.new_device.\n    //\n    // XXX: what if the cache is stale, and the user left the room we had in\n    // common and then added new devices before joining this one? --Matthew\n    //\n    // yup, see https://github.com/vector-im/riot-web/issues/2305 --richvdh\n    return this._crypto.downloadKeys(roomMembers, false).then((devices) => {\n        // remove any blocked devices\n        for (const userId in devices) {\n            if (!devices.hasOwnProperty(userId)) {\n                continue;\n            }\n\n            const userDevices = devices[userId];\n            for (const deviceId in userDevices) {\n                if (!userDevices.hasOwnProperty(deviceId)) {\n                    continue;\n                }\n\n                if (userDevices[deviceId].isBlocked() ||\n                    (userDevices[deviceId].isUnverified() &&\n                     (room.getBlacklistUnverifiedDevices() ||\n                      this._crypto.getGlobalBlacklistUnverifiedDevices()))\n                   ) {\n                    delete userDevices[deviceId];\n                }\n            }\n        }\n\n        return devices;\n    });\n};\n\n/**\n * Megolm decryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/base.DecryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/base.DecryptionAlgorithm}\n */\nfunction MegolmDecryption(params) {\n    base.DecryptionAlgorithm.call(this, params);\n\n    // events which we couldn't decrypt due to unknown sessions / indexes: map from\n    // senderKey|sessionId to list of MatrixEvents\n    this._pendingEvents = {};\n\n    // this gets stubbed out by the unit tests.\n    this.olmlib = olmlib;\n}\nutils.inherits(MegolmDecryption, base.DecryptionAlgorithm);\n\n/**\n * @inheritdoc\n *\n * @param {MatrixEvent} event\n *\n * returns a promise which resolves to a\n * {@link module:crypto~EventDecryptionResult} once we have finished\n * decrypting, or rejects with an `algorithms.DecryptionError` if there is a\n * problem decrypting the event.\n */\nMegolmDecryption.prototype.decryptEvent = async function(event) {\n    const content = event.getWireContent();\n\n    if (!content.sender_key || !content.session_id ||\n        !content.ciphertext\n       ) {\n        throw new base.DecryptionError(\"Missing fields in input\");\n    }\n\n    let res;\n    try {\n        res = await this._olmDevice.decryptGroupMessage(\n            event.getRoomId(), content.sender_key, content.session_id, content.ciphertext,\n        );\n    } catch (e) {\n        if (e.message === 'OLM.UNKNOWN_MESSAGE_INDEX') {\n            this._addEventToPendingList(event);\n            this._requestKeysForEvent(event);\n        }\n        throw new base.DecryptionError(\n            e.toString(), {\n                session: content.sender_key + '|' + content.session_id,\n            },\n        );\n    }\n\n    if (res === null) {\n        // We've got a message for a session we don't have.\n        this._addEventToPendingList(event);\n        this._requestKeysForEvent(event);\n        throw new base.DecryptionError(\n            \"The sender's device has not sent us the keys for this message.\",\n            {\n                session: content.sender_key + '|' + content.session_id,\n            },\n        );\n    }\n\n    const payload = JSON.parse(res.result);\n\n    // belt-and-braces check that the room id matches that indicated by the HS\n    // (this is somewhat redundant, since the megolm session is scoped to the\n    // room, so neither the sender nor a MITM can lie about the room_id).\n    if (payload.room_id !== event.getRoomId()) {\n        throw new base.DecryptionError(\n            \"Message intended for room \" + payload.room_id,\n        );\n    }\n\n    return {\n        clearEvent: payload,\n        senderCurve25519Key: res.senderKey,\n        claimedEd25519Key: res.keysClaimed.ed25519,\n        forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain,\n    };\n};\n\nMegolmDecryption.prototype._requestKeysForEvent = function(event) {\n    const sender = event.getSender();\n    const wireContent = event.getWireContent();\n\n    // send the request to all of our own devices, and the\n    // original sending device if it wasn't us.\n    const recipients = [{\n        userId: this._userId, deviceId: '*',\n    }];\n    if (sender != this._userId) {\n        recipients.push({\n            userId: sender, deviceId: wireContent.device_id,\n        });\n    }\n\n    this._crypto.requestRoomKey({\n        room_id: event.getRoomId(),\n        algorithm: wireContent.algorithm,\n        sender_key: wireContent.sender_key,\n        session_id: wireContent.session_id,\n    }, recipients);\n};\n\n/**\n * Add an event to the list of those we couldn't decrypt the first time we\n * saw them.\n *\n * @private\n *\n * @param {module:models/event.MatrixEvent} event\n */\nMegolmDecryption.prototype._addEventToPendingList = function(event) {\n    const content = event.getWireContent();\n    const k = content.sender_key + \"|\" + content.session_id;\n    if (!this._pendingEvents[k]) {\n        this._pendingEvents[k] = [];\n    }\n    this._pendingEvents[k].push(event);\n};\n\n/**\n * @inheritdoc\n *\n * @param {module:models/event.MatrixEvent} event key event\n */\nMegolmDecryption.prototype.onRoomKeyEvent = function(event) {\n    const content = event.getContent();\n    const sessionId = content.session_id;\n    let senderKey = event.getSenderKey();\n    let forwardingKeyChain = [];\n    let exportFormat = false;\n    let keysClaimed;\n\n    if (!content.room_id ||\n        !sessionId ||\n        !content.session_key\n       ) {\n        console.error(\"key event is missing fields\");\n        return;\n    }\n\n    if (!senderKey) {\n        console.error(\"key event has no sender key (not encrypted?)\");\n        return;\n    }\n\n    if (event.getType() == \"m.forwarded_room_key\") {\n        exportFormat = true;\n        forwardingKeyChain = content.forwarding_curve25519_key_chain;\n        if (!utils.isArray(forwardingKeyChain)) {\n            forwardingKeyChain = [];\n        }\n\n        // copy content before we modify it\n        forwardingKeyChain = forwardingKeyChain.slice();\n        forwardingKeyChain.push(senderKey);\n\n        senderKey = content.sender_key;\n        if (!senderKey) {\n            console.error(\"forwarded_room_key event is missing sender_key field\");\n            return;\n        }\n\n        const ed25519Key = content.sender_claimed_ed25519_key;\n        if (!ed25519Key) {\n            console.error(\n                `forwarded_room_key_event is missing sender_claimed_ed25519_key field`,\n            );\n            return;\n        }\n\n        keysClaimed = {\n            ed25519: ed25519Key,\n        };\n    } else {\n        keysClaimed = event.getKeysClaimed();\n    }\n\n    console.log(`Adding key for megolm session ${senderKey}|${sessionId}`);\n    this._olmDevice.addInboundGroupSession(\n        content.room_id, senderKey, forwardingKeyChain, sessionId,\n        content.session_key, keysClaimed,\n        exportFormat,\n    ).then(() => {\n        // cancel any outstanding room key requests for this session\n        this._crypto.cancelRoomKeyRequest({\n            algorithm: content.algorithm,\n            room_id: content.room_id,\n            session_id: content.session_id,\n            sender_key: senderKey,\n        });\n\n        // have another go at decrypting events sent with this session.\n        this._retryDecryption(senderKey, sessionId);\n    }).catch((e) => {\n        console.error(`Error handling m.room_key_event: ${e}`);\n    });\n};\n\n/**\n * @inheritdoc\n */\nMegolmDecryption.prototype.hasKeysForKeyRequest = function(keyRequest) {\n    const body = keyRequest.requestBody;\n\n    return this._olmDevice.hasInboundSessionKeys(\n        body.room_id,\n        body.sender_key,\n        body.session_id,\n        // TODO: ratchet index\n    );\n};\n\n/**\n * @inheritdoc\n */\nMegolmDecryption.prototype.shareKeysWithDevice = function(keyRequest) {\n    const userId = keyRequest.userId;\n    const deviceId = keyRequest.deviceId;\n    const deviceInfo = this._crypto.getStoredDevice(userId, deviceId);\n    const body = keyRequest.requestBody;\n\n    this.olmlib.ensureOlmSessionsForDevices(\n        this._olmDevice, this._baseApis, {\n            [userId]: [deviceInfo],\n        },\n    ).then((devicemap) => {\n        const olmSessionResult = devicemap[userId][deviceId];\n        if (!olmSessionResult.sessionId) {\n            // no session with this device, probably because there\n            // were no one-time keys.\n            //\n            // ensureOlmSessionsForUsers has already done the logging,\n            // so just skip it.\n            return null;\n        }\n\n        console.log(\n            \"sharing keys for session \" + body.sender_key + \"|\"\n            + body.session_id + \" with device \"\n            + userId + \":\" + deviceId,\n        );\n\n        return this._buildKeyForwardingMessage(\n            body.room_id, body.sender_key, body.session_id,\n        );\n    }).then((payload) => {\n        const encryptedContent = {\n            algorithm: olmlib.OLM_ALGORITHM,\n            sender_key: this._olmDevice.deviceCurve25519Key,\n            ciphertext: {},\n        };\n\n        return this.olmlib.encryptMessageForDevice(\n            encryptedContent.ciphertext,\n            this._userId,\n            this._deviceId,\n            this._olmDevice,\n            userId,\n            deviceInfo,\n            payload,\n        ).then(() => {\n            const contentMap = {\n                [userId]: {\n                    [deviceId]: encryptedContent,\n                },\n            };\n\n            // TODO: retries\n            return this._baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n        });\n    }).done();\n};\n\nMegolmDecryption.prototype._buildKeyForwardingMessage = async function(\n    roomId, senderKey, sessionId,\n) {\n    const key = await this._olmDevice.getInboundGroupSessionKey(\n        roomId, senderKey, sessionId,\n    );\n\n    return {\n        type: \"m.forwarded_room_key\",\n        content: {\n            algorithm: olmlib.MEGOLM_ALGORITHM,\n            room_id: roomId,\n            sender_key: senderKey,\n            sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,\n            session_id: sessionId,\n            session_key: key.key,\n            chain_index: key.chain_index,\n            forwarding_curve25519_key_chain: key.forwarding_curve25519_key_chain,\n        },\n    };\n};\n\n/**\n * @inheritdoc\n *\n * @param {module:crypto/OlmDevice.MegolmSessionData} session\n */\nMegolmDecryption.prototype.importRoomKey = function(session) {\n    this._olmDevice.importInboundGroupSession(session);\n\n    // have another go at decrypting events sent with this session.\n    this._retryDecryption(session.sender_key, session.session_id);\n};\n\n/**\n * Have another go at decrypting events after we receive a key\n *\n * @private\n * @param {String} senderKey\n * @param {String} sessionId\n */\nMegolmDecryption.prototype._retryDecryption = function(senderKey, sessionId) {\n    const k = senderKey + \"|\" + sessionId;\n    const pending = this._pendingEvents[k];\n    if (!pending) {\n        return;\n    }\n\n    delete this._pendingEvents[k];\n\n    for (let i = 0; i < pending.length; i++) {\n        pending[i].attemptDecryption(this._crypto);\n    }\n};\n\nbase.registerAlgorithm(\n    olmlib.MEGOLM_ALGORITHM, MegolmEncryption, MegolmDecryption,\n);\n"]}